#summary Interface specification for Intents and Content Providers
#labels Featured

<wiki:toc max_depth="3" />

=Content Provider Overview=
Using Content Providers may be intimidating at first. Once you learn the ropes, however, it's fun to see the implicit Intent resolution work, and you may decide that Content Providers are a beautiful system for writing interoperable applications.

==Event sequence==
The following steps are approximately what happens under the hood when your application wants to plot data with *`ChartDroid`*.
  # Application launches an `Intent` with `ACTION_VIEW` and a URI to its content provider
  # Android calls the content provider's `getType()` method
  # Android resolves the appropriate *`ChartDroid`* `Activity` as an `Intent` match for the combination of `ACTION_VIEW` and the returned data type
  # *`ChartDroid`* activity is launched
  # *`ChartDroid`* initiates a query on the specified URI for the data that should be plotted
  # Android uses the "authority" portion of the URI to instantiate the correct `ContentProvider` (yours), according to your application's `AndroidManifest.xml`
  # *`ChartDroid`* receives data from your `ContentProvider` and plots it onscreen

To make this process go as planned, you must
  # Subclass `ContentProvider` and handle the `getType()` and `query()` methods
    * `getType()` should return [#Data_type one of these type strings]
    * `query()` can either directly query your SQLite database, or generate data on the fly with `MatrixCursor`. If you intend to use this `ContentProvider` for multiple types of queries, you can use a UriMatcher to choose between different queries based on the "path" of your `Uri`, or you can devise your own `switch` cases based on query parameters added to the `Uri`.
  # Declare the content provider in your `AndroidManifest.xml` with an "authority" string of your choosing.  Usually it should start with your application's package name, to help ensure that it is unique system-wide.
  # Construct a `Uri` using the aforementioned authority


=Charts in version 2.x=

==Data type==
There are several ways to present data with *`ChartDroid`*. To give the user a choice among all of them, the [http://developer.android.com/reference/android/content/ContentProvider.html#getType%28android.net.Uri%29 getType()] method of your Content Provider should respond with the string:
`vnd.android.cursor.dir/vnd.com.googlecode.chartdroid.graphable`

For event data (values plotted against a time axis; timelines), `getType()` should return:
`vnd.android.cursor.dir/vnd.com.googlecode.chartdroid.timeline`

To limit the presentation options, categories may be added to the Intent:
  * Radial: `com.googlecode.chartdroid.intent.category.PIE_CHART`
    * Pie charts and donut charts
  * X-Y: `com.googlecode.chartdroid.intent.category.XY_CHART`
    * Bar charts, line charts


==Content Provider==
Your Content Provider should respond to three types of queries:
  * `data`
  * `meta`
  * `axes`

~~When displaying a chart, these strings will be appended to the source Uri as a "callback" to retrieve the various chart data. Therefore, a Content Provider should examine the last path component of the Uri and serve the appropriate columns below.~~

When displaying a chart, these strings will be appended *as a value of the "aspect" query parameter* of the source Uri as a "callback" to retrieve the various chart data. Therefore, a Content Provider should examine the "aspect" parameter of the Uri and serve the appropriate columns below. (Using query parameters for this instead of the last path segment permits use of the `ContentUris.parseId()` function.)
{{{
if ("axes".equals(uri.getQueryParameter("aspect") )) {
   ... // serve the axes data
} else if ("meta".equals(uri.getQueryParameter("aspect") )) {
   ... // serve the meta data
} else {
   ... // serve the data 
}
}}}

*Note:* The data to chart may be generated dynamically in the client by populating a [http://developer.android.com/reference/android/database/MatrixCursor.html MatrixCursor].  If your data already exists in an SQLite-backed database, it is simple to translate the column names.  Use a query such as:
{{{
String[] projection = new String[] {
    "ROWID AS " + BaseColumns._ID,    // ROWID is the implicit Primary Key generator in SQLite
    MY_AXIS_INDEX_COLUMN + " AS " + "COLUMN_AXIS_INDEX",
    MY_SERIES_INDEX_COLUMN + " AS " + "COLUMN_SERIES_INDEX",
    ...
};

db.query(MY_TABLE, projection, ...);
}}}


==="data" Columns===

Datum component values will be interpreted as `double` type.

Datum labels may be specified or left `null`.

Developers may choose between the scheme below or an [AlternateColumnScheme alternate column scheme]. Currently the "`_id`" column is ignored in both schemes.

====Standard Column Scheme====

In this scheme, all datum components are in the same row.  This scheme is assumed if there exist any column names that start with the prefix "`AXIS_`".  Axes are ordered lexographically.

|| *Column name* || *Data type* ||
|| `_id` || `long` ||
|| `COLUMN_SERIES_INDEX` || `int` ||
|| `COLUMN_DATUM_LABEL` || `String` ||
|| `AXIS_A` || `double` ||
|| `AXIS_B` || `double` ||
|| `AXIS_C` || `double` ||
|| `...` || `double` ||

Here is an example results table that could be produced in response to a "data" query:

|| `_id` || `COLUMN_SERIES_INDEX` || `COLUMN_DATUM_LABEL` || `AXIS_X`  || `AXIS_Y` ||
|| 3546 || 0 || "beef" || 17 || 4 ||
|| 3548 || 0 || "chicken" || 24 || 6 ||
|| 3550 || 0 || "pork" || 13 || 8 ||
|| 3552 || 1 || "apples" || 30 || 10 ||
|| 3554 || 1 || "oranges" || 12 || 4 ||
|| 3556 || 1 || "pears" || 5 || 2 ||

==="meta" Columns===
The "meta" query provides labels for each data series.

|| *Column name* || *Data type* ||
|| `_id` || `long` ||
|| `COLUMN_SERIES_LABEL` || `String` ||


==="axes" Columns===
The "axes" query provides labels for each axis.

|| *Column name* || *Data type* || *Optional* ||
|| `_id` || `long` || Y ||
|| `COLUMN_AXIS_LABEL` || `String` || N ||
|| `COLUMN_AXIS_MIN` (todo) || `double` || Y ||
|| `COLUMN_AXIS_MAX` (todo) || `double` || Y ||

If the columns `COLUMN_AXIS_MIN` and `COLUMN_AXIS_MAX` are not present, the axis min and max are calculated automatically, and the axis limits are set to ten percent above and below the data range.

==Intent Extras==

The only really "mandatory" query in your Content Provider is `data`; other aspects of the chart may be delivered through Intent extras.  The Intent extras, if present, take precedence over the Content Provider.

|| *Key* || *Data type* ||
|| `Intent.EXTRA_TITLE` || `String` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_COLORS` || `int[]` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_LABELS ` || `String[]` ||
|| `com.googlecode.chartdroid.intent.extra.AXIS_TITLES` || `ArrayList<String>` ||
|| `com.googlecode.chartdroid.intent.extra.FORMAT_STRING_X` || `String` ||
|| `com.googlecode.chartdroid.intent.extra.FORMAT_STRING_Y` || `String` ||


=Charts in version 1.x=
==Actions==
  * com.googlecode.chartdroid.intent.action.PLOT
==Categories==
  * com.googlecode.chartdroid.intent.category.PIE_CHART
  * com.googlecode.chartdroid.intent.category.CALENDAR
==Extras==

===Pie Chart===
|| *Key* || *Data type* || *Required? ||
|| `com.googlecode.chartdroid.intent.extra.DATA` || `int[]` || Y ||
|| `com.googlecode.chartdroid.intent.extra.LABELS` || `String[]` || N ||
|| `com.googlecode.chartdroid.intent.extra.COLORS` || `int[]` || N ||
|| `Intent.EXTRA_TITLE` || `String` || N ||