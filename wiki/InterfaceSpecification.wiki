#summary Interface specification for Intents and Content Providers
#labels Featured

<wiki:toc max_depth="3" />

=Content Provider Overview=
Using Content Providers may be intimidating at first. Once you learn the ropes, however, it's fun to see the implicit Intent resolution work, and you may decide that Content Providers are a beautiful system for writing interoperable applications.

==Event sequence==
The following steps are approximately what happens under the hood when your application wants to plot data with *`ChartDroid`*.
  # Application launches an `Intent` with `ACTION_VIEW` and a `Uri` that will be used to query its `ContentProvider`
  # Android calls the content provider's `getType()` method
  # Android resolves the appropriate *`ChartDroid`* `Activity` as an `Intent` match for the combination of `ACTION_VIEW` and the returned data type
  # *`ChartDroid`* activity is launched
  # *`ChartDroid`* initiates a query on the specified `Uri` for the data that should be plotted
  # Android uses the "authority" portion of the `Uri` to instantiate the correct `ContentProvider` (yours), according to your application's `AndroidManifest.xml`
  # *`ChartDroid`* receives data from your `ContentProvider` and plots it onscreen

To make this process go as planned, you must
  # Subclass `ContentProvider` and handle the `getType()` and `query()` methods
    * `getType()` should return [#Data_type one of these type strings]
    * `query()` can either directly query your SQLite database, or generate data on the fly with `MatrixCursor`. If you intend to use this `ContentProvider` for multiple types of queries, you can use a `UriMatcher` to choose between different queries based on the "path" of your `Uri`, or you can devise your own `switch` cases based on [http://developer.android.com/reference/android/net/Uri.Builder.html#appendQueryParameter%28java.lang.String,%20java.lang.String%29 query parameters added] to the `Uri`.
  # Declare the content provider in your `AndroidManifest.xml` with an "authority" string of your choosing.  Usually it should start with your application's package name, to help ensure that it is unique system-wide.
  # Construct a `Uri` using the aforementioned authority

=Charts in version 2.x=
==Terms==
In this document:
  * The term *datum* refers to a single "point" on the graph, which may be multidimensional.
  * The term *datum component* is a single scalar value for one of the dimensions of a *datum*.

==Data type==
There are several ways to present data with *`ChartDroid`*. To give the user a choice among all of them, the [http://developer.android.com/reference/android/content/ContentProvider.html#getType%28android.net.Uri%29 getType()] method of your Content Provider should return the string:
`vnd.android.cursor.dir/vnd.com.googlecode.chartdroid.graphable`

For event data (values plotted against a time axis; timelines), `getType()` should return:
`vnd.android.cursor.dir/vnd.com.googlecode.chartdroid.timeline`

To limit the presentation options, [http://developer.android.com/reference/android/content/Intent.html#addCategory%28java.lang.String%29 categories may be added] to the Intent:
  * *Radial:* `com.googlecode.chartdroid.intent.category.PIE_CHART`
    * Pie charts and donut charts
  * *X-Y:* `com.googlecode.chartdroid.intent.category.XY_CHART`
    * Bar charts, line charts

==Content Provider==
Your Content Provider should respond to three types of queries:
  * `data`
  * `series`
  * `axes`

~~When displaying a chart, these strings will be appended to the source Uri as a "callback" to retrieve the various chart data. Therefore, a Content Provider should examine the last path component of the Uri and serve the appropriate columns below.~~

When displaying a chart, these strings will be appended *as a value of the "aspect" query parameter* of the source Uri as a "callback" to retrieve the various chart data. Therefore, a Content Provider should examine the "aspect" parameter of the Uri and serve the appropriate columns below. (Using query parameters for this instead of the last path segment permits use of the `ContentUris.parseId()` function.)
{{{
if ("axes".equals(uri.getQueryParameter("aspect") )) {
   ... // serve the axes metadata
} else if ("series".equals(uri.getQueryParameter("aspect") )) {
   ... // serve the series metadata
} else {
   ... // serve the data 
}
}}}

*Note:* The data to chart may be generated dynamically in the client by populating a [http://developer.android.com/reference/android/database/MatrixCursor.html MatrixCursor].  If your data already exists in an SQLite-backed database, it is simple to translate the column names.  Use a query such as:
{{{
String[] projection = new String[] {
    "ROWID AS " + BaseColumns._ID,    // ROWID is the implicit Primary Key generator in SQLite
    MY_AXIS_INDEX_COLUMN + " AS " + "COLUMN_AXIS_INDEX",
    MY_SERIES_INDEX_COLUMN + " AS " + "COLUMN_SERIES_INDEX",
    ...
};

db.query(MY_TABLE, projection, ...);
}}}


==="data" Columns===

Datum component values will be interpreted as `double` type.

Datum labels may be specified or left `null`.

Developers may choose between the scheme below or an [AlternateColumnScheme alternate column scheme]. Currently the "`_id`" column is ignored in both schemes.

====Standard Column Scheme====

In this scheme, all datum components are in the same row.  This scheme is assumed if there exist any column names that start with the prefix "`AXIS_`".  Axes are ordered lexographically.

|| *Column name* || *Data type* ||
|| `_id` || `long` ||
|| `COLUMN_SERIES_INDEX` || `int` ||
|| `COLUMN_DATUM_LABEL` || `String` ||
|| `AXIS_A` || `double` ||
|| `AXIS_B` || `double` ||
|| `AXIS_C` || `double` ||
|| `...` || `double` ||

Here is an example results table that your application might produce in response to a "data" query:

|| `_id` || `COLUMN_SERIES_INDEX` || `COLUMN_DATUM_LABEL` || `AXIS_X`  || `AXIS_Y` ||
|| 3546 || 0 || "beef" || 17 || 4 ||
|| 3548 || 0 || "chicken" || 24 || 6 ||
|| 3550 || 0 || "pork" || 13 || 8 ||
|| 3552 || 1 || "apples" || 30 || 10 ||
|| 3554 || 1 || "oranges" || 12 || 4 ||
|| 3556 || 1 || "pears" || 5 || 2 ||

==="series" Columns===
The "series" query provides labels for each data series. All columns are optional.

|| *Column name* || *Data type* ||
|| `_id` || `long` ||
|| `COLUMN_SERIES_LABEL` || `String` ||
|| `COLUMN_SERIES_COLOR` || `int` ||
|| `COLUMN_SERIES_MARKER` || `int` ||
|| `COLUMN_SERIES_LINE_STYLE` || `int` ||
|| `COLUMN_SERIES_LINE_THICKNESS` || `float` ||

==="axes" Columns===
The "axes" query provides labels for each axis.

|| *Column name* || *Data type* || *Optional* ||
|| `_id` || `long` || Y ||
|| `COLUMN_AXIS_LABEL` || `String` || N ||
|| `COLUMN_AXIS_MIN` (todo) || `double` || Y ||
|| `COLUMN_AXIS_MAX` (todo) || `double` || Y ||

If the columns `COLUMN_AXIS_MIN` and `COLUMN_AXIS_MAX` are not present, the axis min and max are calculated automatically, and the axis limits are set to ten percent above and below the data range.

==Intent Extras==

The only really "mandatory" query in your Content Provider is `data`; other aspects of the chart may be delivered through Intent extras.  The Intent extras, if present, take precedence over the Content Provider.

|| *Key* || *Data type* ||
|| `Intent.EXTRA_TITLE` || `String` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_LABELS` || `String[]` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_COLORS` || `int[]` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_MARKERS` || `int[]` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_LINE_STYLES` || `int[]` ||
|| `com.googlecode.chartdroid.intent.extra.SERIES_LINE_THICKNESSES` || `float[]` ||
|| `com.googlecode.chartdroid.intent.extra.AXIS_TITLES` || `ArrayList<String>` ||
|| `com.googlecode.chartdroid.intent.extra.FORMAT_STRING_X` || `String` ||
|| `com.googlecode.chartdroid.intent.extra.FORMAT_STRING_Y` || `String` ||


=Charts in version 1.x=
==Actions==
  * com.googlecode.chartdroid.intent.action.PLOT
==Categories==
  * com.googlecode.chartdroid.intent.category.PIE_CHART
  * com.googlecode.chartdroid.intent.category.CALENDAR
==Extras==

===Pie Chart===
|| *Key* || *Data type* || *Required? ||
|| `com.googlecode.chartdroid.intent.extra.DATA` || `int[]` || Y ||
|| `com.googlecode.chartdroid.intent.extra.LABELS` || `String[]` || N ||
|| `com.googlecode.chartdroid.intent.extra.COLORS` || `int[]` || N ||
|| `Intent.EXTRA_TITLE` || `String` || N ||

=Defining Java Constants=
One approach you could take (though I make no promises), is the following:

In your application's `src/` directory, create the directory tree
`com/googlecode/chartdroid`.
Then `cd` to the leaf directory you just created, and set the externals property to keep your project in sync with the *`chartdroid`* definitions.

{{{
cd src
mkdir -p com/googlecode/chartdroid
svn add com
cd com/googlecode/chartdroid
svn propset svn:externals 'core http://chartdroid.googlecode.com/svn/trunk/core/src/com/googlecode/chartdroid/core' .
cd ../../..
svn ci -m "added constants defined in external repo"
svn up
}}}

Now when you call `svn up` in your project, it automatically fetches the contants I've defined for use with *`chartdroid`*.